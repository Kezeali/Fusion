FusionPhysics will have its own self contained environment, or "world", in which a generic collision body will represent each object. The bitmask for the terrain will be generated using a method in the FusionPhysicsBodyTerrain class, using a pixelbuffer passed to it. The abstract class FusionPhysicsBody will contain members used by all physicals; check collision, collision callback, etc. FusionPhysicsBodyShip will use a get a pointer to a shipstate to source its data -> getMass() { m_ship.currentstate.mass } or something.

Shouldn't be a drawable - it should simply be a place for storing state data. FusionShipDrawable should be the drawable, and it should do something like this: Draw() {m_ship.currentstate.position.x ... } later i may add a FusionShipServerDrawable - but FusionDrawable won't be called Client because this is uncertain!