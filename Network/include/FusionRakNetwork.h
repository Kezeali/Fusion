/*
 Copyright (c) 2007-2009 Fusion Project Team

 This software is provided 'as-is', without any express or implied warranty.
	In noevent will the authors be held liable for any damages arising from the
	use of this software.

 Permission is granted to anyone to use this software for any purpose,
	including commercial applications, and to alter it and redistribute it
	freely, subject to the following restrictions:

 1. The origin of this software must not be misrepresented; you must not
 claim that you wrote the original software. If you use this software in a
 product, an acknowledgment in the product documentation would be
 appreciated but is not required.

 2. Altered source versions must be plainly marked as such, and must not
 be misrepresented as being the original software.

 3. This notice may not be removed or altered from any source distribution.
*/

#ifndef H_FusionEngine_RakNetwork
#define H_FusionEngine_RakNetwork

#if _MSC_VER > 1000
#pragma once
#endif

#include "FusionPrerequisites.h"

// RakNet
#include <RakPeerInterface.h>
#include <RakNetTypes.h>
#include <MessageIdentifiers.h>
// Plugins
#include <FullyConnectedMesh2.h>
#include <ConnectionGraph2.h>

#include <tbb/atomic.h>
#include <tbb/spin_mutex.h>

#include "FusionEasyPacket.h"
#include "FusionNetworkTypes.h"

#include <set>

namespace FusionEngine
{

	/*
	// Here's an idea (for more verbose Send() calls):
	template <NetPriority _priority, NetReliability _reliability, char _channel>
	struct PacketSequencingData
	{
		static const NetPriority priority = _priority;
		static const NetReliability reliability = _reliability;
		static const char channel = _channel;
	};

	typedef PacketSequencingData<HIGH_PRIORITY, RELIABLE, 0> StepControlSeqData;

	// And to use it:
	m_Network->Send(To::Arbiter(), !Timestamped, MTID_REQUESTSTEPCONTROL, nullptr, StepControlSeqData::priority, StepControlSeqData::reliability, StepControlSeqData::channel);
	*/

	//! Fusion Packet priority enumeration
	//enum NetPriority
	//{
	//	HIGH_PRIORITY = ::HIGH_PRIORITY,
	//	MEDIUM_PRIORITY = ::MEDIUM_PRIORITY,
	//	LOW_PRIORITY = ::LOW_PRIORITY
	//};

	//! Fusion Packet reliability enumeration
	//enum NetReliability
	//{
	//	UNRELIABLE = ::UNRELIABLE,
	//	UNRELIABLE_SEQUENCED = ::UNRELIABLE_SEQUENCED,
	//	RELIABLE = ::RELIABLE,
	//	RELIABLE_ORDERED = ::RELIABLE_ORDERED,
	//	RELIABLE_SEQUENCED = ::RELIABLE_SEQUENCED
	//};

	//inline PacketPriority rakPriority(NetPriority priority)
	//{
	//	return (PacketPriority)priority;
	//}
	//inline PacketReliability rakReliability(NetReliability reliability)
	//{
	//	return (PacketReliability)reliability;
	//}

	const bool Timestamped = true;

	//! Somewhere to send a packet
	class NetDestination
	{
	public:
		// Leaving GUID default will instruct the Send method to set it to localhost (UNASSIGNED_SYSTEM_ADDRESS)
		RakNet::RakNetGUID GUID;
		bool Broadcast;

		//! Default ctor
		NetDestination()
			: Broadcast(false)
		{}
		//! Destination with data initialisation
		NetDestination(const RakNet::RakNetGUID &guid, bool broadcast)
			: GUID(guid),
			Broadcast(broadcast)
		{}

		//! Copy constructor
		NetDestination(const NetDestination &copy)
			: GUID(copy.GUID),
			Broadcast(copy.Broadcast)
		{}
		//! Move constructor
		NetDestination(NetDestination&& move)
			: GUID(std::move(move.GUID)),
			Broadcast(std::move(move.Broadcast))
		{}
	};

	//! Keeps track of this peer's rank with reguard to the other peers in the FullyConnectedMesh
	class PeerIndexPlugin : public RakNet::PluginInterface2
	{
	public:
		//! CTOR
		PeerIndexPlugin();

		//! Returns the index which indicates when this peer connected relative to others
		uint8_t GetPeerIndex() const;
		//! Returns true if the given peer is senior to this one
		bool IsSenior(const RakNet::RakNetGUID &peer) const;

	protected:
		//! Picks up a packet generated by ConnectionGraph2 containing a list of peers that joined before this one
		RakNet::PluginReceiveResult OnReceive(RakNet::Packet *packet);
		//! This brings news of senior positions as they open up
		/*!
		* When a connection closed event occors, this method checks to see if the peer leaving was one of the ones 
		* recorded by this plugin in the OnReceive event - i.e. a senior peer* - and if it is this method
		* decrements the value of GetPeerIndex(), indicating that this peer has moved up a rank.
		* <p>*senior peer = a peer that connected before this one, and thus has greater authority</p>
		*/
		void OnClosedConnection(RakNet::SystemAddress systemAddress, RakNet::RakNetGUID rakNetGUID, RakNet::PI2_LostConnectionReason lostConnectionReason);

		tbb::atomic<uint8_t> m_PeerIndex;
		typedef tbb::spin_mutex Mutex_t;
		mutable Mutex_t m_PeersMutex;
		std::set<RakNet::RakNetGUID> m_SeniorPeers;
	};

	const unsigned short s_MaxPeers = 16;

	/*!
	 * \brief
	 * RakNet based network interface
	 */
	class RakNetwork
	{
	public:
		RakNetwork();
		~RakNetwork();

		//! Starts the network
		bool Startup(unsigned short incommingPort);
		//! Connects to a server
		bool Connect(const std::string &host, unsigned short port);
		//! Disconnects cleanly
		void Disconnect();

		bool IsConnected() const;

		size_t GetConnectedPeersCount() const;

		// TODO: add an in-host-order version of this method
		void ForEachPeer(std::function<void (const RakNet::RakNetGUID &)>&& fn);

		//! Returnst he GUID of this machine
		const RakNet::RakNetGUID &GetLocalGUID() const;

		//! 0 to (peerlimit-1) inicates when this peer connected
		/*!
		* Returns an unsigned integer from 0 to (peerlimit-1) indicating when this peer connected
		* in relation to other peers currently connected (lower index means older peer).
		*/
		uint8_t GetPeerIndex() const;

		//! Returns true if the given peer has seniority over this one
		bool IsSenior(const RakNet::RakNetGUID &peer);

		//! Returns true if the first given peer has seniority over the other one
		bool IsSenior(const RakNet::RakNetGUID& expectedSenior, const RakNet::RakNetGUID& expectedJunior);

		//! Gets the host GUID from the FullyConnectedMesh plugin
		RakNet::RakNetGUID GetHost() const;

		//! Sends data as-is (without adding a header)
		/*!
		* Make sure you include an ID as the first byte, or RakNet may eat the message! :S
		*/
		bool SendAsIs(const NetDestination &dest,
			const char* data, unsigned int length,
			PacketPriority priority, PacketReliability reliability, char channel);

		//! Sends a RakNet#BitStream as-is (without adding a header)
		/*!
		* Make sure you include an ID as the first byte, or RakNet may eat the message! :O
		*/
		bool SendAsIs(const NetDestination &dest,
			const RakNet::BitStream *bitStream,
			PacketPriority priority, PacketReliability reliability, char channel);

		//! Prepends the given data with a header and sends it
		/*!
		 * <b>Packet Format
		 * <ol>
		 *  <li> [bool]          Time stamp marker (indicates the packet is timestamped)
		 *  <li> [unsigned int]  Time stamp (if the time stamp marker was 'true')
		 *  <li> [unsigned char] Type ID
		 *  <li> [...]           The given data
		 * </ol>
		 */
		virtual bool Send(const NetDestination &destination,
			bool timestamped, unsigned char type, char* data, unsigned int length,
			PacketPriority priority, PacketReliability reliability, char channel);

		//! Prepends the given RakNet#BitStream with a header and sends it
		bool Send(const NetDestination &destination,
			bool timestamped, unsigned char type, RakNet::BitStream *data,
			PacketPriority priority, PacketReliability reliability, char channel);
		
		//! Receives data
		RakNet::Packet *Receive();

		//! Receives data, returning an smart-ptr (probably std::shared_ptr<Packet>)
		PacketSpt ReceivePacketSpt();

		//! Puts the given packet back on the receive buffer
		void PushBackPacket(RakNet::Packet *packet, bool to_head = false);

		// It's not obvious how you could validly push back a packet-spt, since doing
		//  so would need to invalidate all other copies of that spt (it could be done
		//  if ReceivePacketSpt returned a weak_ptr, but that's too much hassle when you
		//  could just use a raw packet in the cases when you want to be able to push
		//  them back), hence this method is removed.
		//void PushBackPacket(const PacketSpt &packet, bool to_head = false);

		//! Deletes a packet
		void DeallocatePacket(RakNet::Packet* packet);

		//! Returns RakNet stats
		std::shared_ptr<RakNet::RakNetStatistics> GetStatistics(const RakNet::RakNetGUID &guid);

		//! Gets the ping to the given host
		int GetPing(const RakNet::RakNetGUID& guid);
		int GetLastPing(const RakNet::RakNetGUID& guid);
		int GetAveragePing(const RakNet::RakNetGUID& guid);
		int GetLowestPing(const RakNet::RakNetGUID& guid);

		const RakNet::RakPeerInterface* GetPeerInterface() const { return m_NetInterface; }
		RakNet::RakPeerInterface* GetPeerInterface() { return m_NetInterface; }

		//! Uses RakPeerInterface#ApplyNetworkSimulator to introduce fake lag
		/*!
		 * \param minLagMilis
		 * The minimum amount of lag time (milisecods) applied to communications
		 *
		 * \param variance
		 * Extra lag time (milisecods) which may be randomly applied
		 */
		void SetDebugLag(unsigned int minLagMilis, unsigned int variance);
		//! Uses RakPeerInterface#ApplyNetworkSimulator to introduce fake packet loss
		/*!
		 * \param allowBps
		 * Maximum bits per second before packet loss
		 */
		void SetDebugPacketLoss(float allowBps);

		//! Returns the current fake lag setting
		unsigned int GetDebugLagMin() const;
		//! Returns the current fake lag variance setting
		unsigned int GetDebugLagVariance() const;
		//! Returns the current fake packet loss setting
		float GetDebugAllowBps() const;

		
	protected:
		RakNet::RakPeerInterface* m_NetInterface;
		RakNet::FullyConnectedMesh2 m_FullyConnectedMeshPlugin;
		RakNet::ConnectionGraph2 m_ConnectionGraphPlugin;
		PeerIndexPlugin m_PeerIndexPlugin;

		// Network Simulator settings
		unsigned int m_MinLagMilis;
		unsigned int m_LagVariance;
		float m_AllowBps;
	};

}

#endif
